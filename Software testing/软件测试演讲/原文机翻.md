# 测试集直径：量化测试用例集的多样性

## 抽象：
软件测试人员之间的一个普遍而自然的直觉是，如果要正确测试软件系统并确保其质量，则测试用例需要有所不同。因此，许多研究已经着手制定距离度量，以测试用例，其输入和/或输出如何不同。但是，这些建议的共同点是它们特定于数据类型和/或仅计算成对的测试输入，迹线或输出之间的差异。我们提出了一种新的度量标准来衡量测试集的多样性：测试集直径（TSDm）。**它基于信息理论中有关多集归一化压缩距离（NCD）计算的最新进展，扩展了我们较早的成对测试多样性指标。一个关键的优点是，TSDm是通用的多样性度量，因此可以将其应用于任何测试集，而与测试输入的数据类型无关（此外，还可以应用于其他与测试相关的数据，例如执行跟踪）**。但是，与竞争性方法相比，**这种普遍性是以更大的计算工作为代价的**。我们在四种不同系统上的实验表明，即使仅应用于测试输入，测试集直径也可以帮助选择结构和故障覆盖率比随机选择更高的测试集。这样甚至可以在没有软件系统进行测试之前进行早期测试设计和选择，并补充其他类型的测试自动化和分析功能。我们认为测试集多样性的这种量化为更好地理解软件质量提供了许多机会，并提供了提高质量的实用方法。

## 第一节 引言

测试是确保软件具有足够质量和可靠性的关键活动。由于软件项目经常超出分配给它们的时间和资源，因此测试经常必须充分利用最少的资源。即使使用自动化技术执行测试和/或创建测试时，这也会限制可以选择的测试用例的数量。即使有足够的时间计划测试和开发测试用例，通常也会在每次迭代内或每个发行版之前频繁地重新执行测试，**这意味着我们需要尽可能少的有效测试集。因此，软件测试中的一个基本问题是如何选择一小组最有效地测试软件系统的测试用例。**

为了实现这些目标，**测试人员之间的直觉是选择一小组不同的测试用例。这个想法是，不同的测试用例更有可能更好地涵盖预期的和实际的软件行为**。这种方法在研究文献中也有支持。例如，自适应随机测试[1]仅在距现有测试用例很远的情况下才添加一个新的，随机生成的测试用例。但陈等。 [1]还请注意，诸如Restricted- [2]，Anti- [3]和Quasi- [4]随机测试之类的许多测试方法都基于相同的思想：在输入中“均匀分布”测试用例域。这些技术成功的关键是普遍适用的多样性测度，Chen等。甚至说“我们已经意识到，“均匀分布”可以更好地描述为一种多样性形式” [1]。他们描述了一种基于类别-分区（分区测试）方法的距离计算方案，但是它要求测试人员手动识别可以更改的类别和级别。

量化测试案例之间差异的大多数方法都是特定于某种类型的数据的。通常会假定数据是数字的，因为可以使用许多现有的距离函数。一个例子是Bueno等人的方法。文献[5]选择了使每个测试输入到其最近邻的距离之和最大的测试集。在他们的经验工作中，他们使用欧几里得距离，该距离要求输入为数值向量。对于定义距离函数并非那么简单的数据类型，研究人员通常会恢复为基本距离形式，例如二进制距离，而不是对其进行量化。例如，Alshawan等。 [6]建议根据唯一的系统输出选择用于Web应用程序测试的测试用例。他们的经验研究[7]在五个Web应用程序的HTML输出上应用了几种唯一性度量。所有的唯一性度量本质上都是二进制的，因为它们基于比较HTML输出各部分之间的相等性。

费尔德等。文献[8]利用信息理论领域的信息距离的概念提出了具有更强理论基础的测试多样性度量[9]。尽管信息距离是基于Kolmogorov复杂度[10]，在实践中只能近似计算，但使用现代压缩算法进行的这种近似计算已显示出广泛的适用性[11] – [12] [13]。使用压缩算法计算的一种此类距离度量是Cilibrasi和Vitanyi的归一化压缩距离（NCD）[14]。除了理论上的动机外，他们的建议也有实际的好处：由于信息距离是通用的，并且适用于任何数据串，因此无论所研究的数据类型如何，都可以使用它。对测试系统开发人员的好处将是立竿见影的。他们不再需要为每个应用程序域或数据类型开发特定的指标。通过基于标准化压缩距离（NCD）进行多样性测量，自动化测试系统通常可以搜索各种测试[8]。

Feldt等人的提议中存在一个根本性的空白。是如何使用所得分集度量的。由于NCD是成对度量，因此它可以计算所有（此处）测试用例对之间的距离矩阵，但是尚不清楚如何利用该信息来选择测试用例。在他们的研究中，费尔德特等人。使用一种通用方法（也曾在提出NCD度量的原始论文中使用过）根据距离对研究对象进行聚类。这种分析的结果是一棵树，该树定义了测试用例之间的近似顺序。但是费尔德特等。没有研究选择测试用例以形成一个小的，多样化的测试集的具体方法。

本文应用了信息理论中的最新成果，该理论将NCD扩展到多集[15]。这提供了一种通用的方法来解决测试选择问题，该问题可以适用于任何类型的测试输入，输出或其他有关测试的信息，例如其执行跟踪。我们的推测是，这种基于理论上动机的基于集合多样性的测试选择方法可以创建比启发式方法（例如Bueno等人[5]使用的最大均值多样性和最大最小化）更有效的测试集。自适应随机测试中使用的多样性[1]。用于多集合的NCD可以以理论上有根据的方式计算整个集合的多样性，而无需基于成对比较对其进行近似。而且，由于基础距离度量本身可以用于任何数据类型，因此该方法也可以应用于尚未知的数据类型或在新的应用程序域中。

第二节介绍了NCD及其对多集的扩展，第三节定义了测试集直径和基于它的测试选择程序。在第四节的实证研究提出研究问题，软件测试，实验过程和结果。最后，我们在第VII节中总结该论文之前，讨论了第IV节中结果的含义，并将其置于第VI节中的相关工作的背景下。

## 第二节 多集的归一化压缩距离
在本节中，我们将描述信息理论中用于此工作的概念：信息距离，其实际近似值（归一化压缩距离（NCD））以及NCD最近扩展到多集的情况。

### A.信息距离及其近似
符号字符串x的Kolmogorov复杂度是输出x [10]的最短程序的长度（通常以位为单位）。它是x中包含的信息的度量，在此将其表示为K（x）。给定y的x的条件Kolmogorov复杂度K（x | y）是在给定输入y的情况下输出x的最短程序的长度。

Bennett等。建议的信息距离作为使用条件Kolmogorov复杂度计算的相似性度量[9]（出于我们的目的，我们将相似性视为多样性的倒数：输入非常相似的测试集缺乏多样性）。对于x和y这两个字符串，信息距离为：
ID（x，y）= max {K（x | y），K（y | x）}（1）
查看SourceRight单击该图以获取MathML和其他功能。

换句话说，实体x和y之间的相似性是最短的程序，将x转换为y，或者最短程序，其将Y到X中较大的长度。 Bennett等。从某种意义上说，信息距离是一个通用的相似性度量，如果任何其他允许的度量检测到x和y之间的相似性，那么信息距离也是如此。

长字符串的Kolmogorov复杂度通常比短字符串大。因此，两个长字符串之间的信息距离通常将大于两个短字符串之间的信息距离。为了能够比较不同尺寸范围的成对弦之间的相似性，Li等人。提出了归一化信息距离（NID），该信息距离使用两个字符串的Kolmogorov复杂度对信息距离进行归一化[16]：
NID（x，y）= max {K（x | y），K（y | x）} max {K（x），K（y）}（2）
查看SourceRight单击该图以获取MathML和其他功能。

NID的取值范围为[0,1]，其中值接近0表示相似度更高。归一化的该特定选择具有NID保留了度量的特性的优点，即是（i）NID（X，X）= 0（身份公理）; （ii）NID（x，y）+ NID（y，z）≥NID（x，z）（三角形公理）； （iii）NID（x，y）= NID（y，x））（对称公理）。

实际上，确定输出给定字符串的最短程序通常是不可行的，因此确定用于计算NID的Kolmogorov复杂度通常是不可行的。 Cilibrasi和Vitáyni描述了一种实际的选择：归一化压缩距离（NCD）[14]。

NCD基于这样的观察：当使用实际压缩程序（例如gzip和bzip2）压缩字符串时，输出的大小很好地近似了其Kolmogorov的复杂性。如果C（x）是通过选定的压缩程序压缩后的字符串x的长度，则NCD由下式给出：
NCD（X，Y）= C（XY）-min {C（X），C（Y）}最大{C（X），C（Y）}（3）
查看SourceRight单击该图以获取MathML和其他功能。其中xy表示x和y的串联。 NCD发生在范围内的值[0,1 +ε]其中ε是依赖于到该压缩程序近似于Kolmogorov复杂度小的正值。

### B.将NCD扩展到多集
NCD是一个成对指标：它的措施相似的两个字符串之间的度。在某些情况下，字符串多集之间的相似性是一个有趣的概念（我们使用严格的术语“多集”而不是“集合”，因为集合可能多次包含同一字符串）。在这种情况下，我们对作为整体考虑的一组测试用例的相似性（或相反，多样性）感兴趣。

最近，Cohen和Vitányi为此目的将NCD的概念扩展到多集。对于多集X，NCD通过中间度量NCD1计算为[15]：

NCD1（X）= C（X）−minx∈X {C（x）}maxx∈X{C（X∖{x}）} （4）

NCD（X）= max {NCD1（X），maxY⊂X{NCD（ Y）}}（5）

在此，C（X）表示以某种特定顺序将字符串串联后，X中压缩字符串的长度（Cohen和Vitányi在[15]中提出了长度增加的字典顺序）。通过将一个字符串的集合的NCD定义为0，两个字符串的多集合的NCD与两个字符串之间的成对NCD相同。

由于术语maxY⊂X{NCD（Y）}需要对X的每个适当子集进行NCD的递归评估，因此多集NCD的计算具有时间复杂度（2N），其中N是多集的大小。这可能会使NCD的计算不可行，除了最小的多集之外。

Cohen和Vitányi提出了一种算法，该算法使用上面（4）中定义的中间度量NCD1对多集[15]近似计算NCD的时间复杂度（N2）。该算法从多重集Y0 = X = {x1，x2，...，xn}开始，并进行如下操作：

1. 查找使C（Yk∖{xi}）最大化的索引i。

2. 令Yk + 1 = Yk∖xi。
3. 从步骤1开始重复，直到子集仅包含两个字符串。

4. 计算NCD（X）为：max0≤k≤n-2 {NCD1（YK）}。

## 第三节 测试装置直径

信息距离及其作为归一化压缩距离（NCD）的实际实现，在用于评估软件测试的相似性（或多样性）时具有吸引人的特征：它具有普遍意义，即“发现了所有有效的特征相似性或认知性”。两个对象之间的相似性” [9]。如果信息距离用于测量输入之间的差异，则可以将其应用于任何数据类型的输入，因此可以消除对特定于域的距离度量的需求，例如Bueno等人使用的数字输入之间的欧几里得距离。 [5]。一旦确定了一种将输入数据类型转储到字符串的一致方法，就可以应用NCD。

度量的通用性和通用性还允许在确定测试用例的多样性时考虑更广泛的信息。在Feldt等人的早期工作中研究了这种好处。 NCD上的应用软件测试[8]。作者提出了一种可变性模型，该模型可识别测试用例可能不同的许多方面。这些方面包括：执行测试之前SUT的设置，测试输入，SUT的执行轨迹，SUT的输出以及执行的非功能性方面（例如性能）。费尔德等。提议这些方面中的任何一个或它们的组合都携带可用于评估测试案例相似性的信息，而一项实证研究表明，将成对NCD用于此目的。

在本文中，我们研究了Cohen和Vitányi[15]最近描述的NCD在多集上的扩展如何使相似性可以通过通用度量在整个测试用例集而不是测试对之间进行度量。

我们引入术语“测试集直径”（TSDm）来表示使用上一部分中定义的NCD进行多集度量的NCD测得的测试集的多样性。使用Feldt等人的可变性模型中确定的方面。 [8]，我们可以定义这样的度量标准系列：输入TSDm，其中NCD是在测试输入的多集上计算的，输出TSDm是从输出的多集计算的，跟踪TSDm是从执行跟踪的多集计算的，等等。

在本文中，我们研究了使用TSDm从更大的潜在测试用例池中选择指定大小的多样化测试集。为此，我们利用了Cohen和Vitányi提出的NCD1算法来对多集的NCD进行近似，如上文II-B节所述。由于此算法使用NCD1度量来近似NCD，因此我们将选择各种测试用例的过程称为TSDm1。

TSDm1过程提供了一组潜在的测试用例，该池的大小至少与所需测试集的大小一样大。在算法的每次迭代中，如第II-B节所述，通过删除测试用例来创建池子集，以使NCD1度量最大化。因此，通过该程序创建了一系列大小递减的测试集，然后选择该序列中所需大小的子集作为多样化的测试集。

## 第四节实证研究
我们专注于评估在基于输入多样性即输入TSDm（I-TSDm）选择测试用例中测试集直径的使用。我们的动机是，这是软件测试自动化中一个更具雄心和新颖的用例。如果可能的话，它甚至可以在开始实施软件系统之前允许选择测试套件，从而进行测试套件的设计。只要存在软件接口的至少部分规范和描述，我们就可以基于它们生成测试输入，并通过I-TSDm从中选择一个小的，多样化的测试集。未来的工作将调查TSDm在测试执行跟踪（如[8]中），被测软件（SUT）的输出以及测试输入，跟踪信息和输出的不同组合方面的应用。

下面，我们通过详细介绍五个研究问题，四个实验主题以及所有研究共有的方法和措施来描述实验的设计。反过来，对于每个研究问题，我们随后都会描述用于回答该问题的具体方法以及结果。

### A.研究问题
由于测试装置直径是一种新的测试指标，因此需要大量的基础实验和实际实验。测试启发式“选择不同的测试用例”中隐含的基本假设是，这样的测试用例更可能涵盖规范的各个部分，从而涵盖了软件的各个部分（因为它实现了规范）。因此，在最基本的水平上，我们期望具有更大测试集直径的测试集具有更高的代码覆盖率。如果不是这种情况，我们似乎不太可能利用任何TSDm指标来改善测试。因此，我们调查的第一个研究问题是：

#### RQ1与代码覆盖率的关系
更高级别的I-TSDm是否与更高级别的代码覆盖率相关联？

我们并不期望任何这样的关联是完美的，但是必须至少存在某种关联，然后任何自动化方法都可以利用。为了研究RQ1，我们考虑从随机生成的测试输入的初始池中随机采样的大量测试输入。我们还改变了子集的大小，以更好地了解对任何观察到的相关性对测试集大小的敏感性。由于我们没有理由期望TSDm值或代码覆盖率值呈正态分布，因此我们使用Spearman秩相关系数来研究TSDm与代码覆盖率之间的关联。这是一种非参数依赖性度量，对值的基础分布不敏感[17]。

如果我们可以在RQ1中找到任何相关性，那么自然就可以研究第三节中描述的TSDm1选择程序是否可以在实践中用于选择更好的测试集。

#### RQ2-结构覆盖能力
与随机选择的测试集相比，基于I-TSDm选择的测试集是否会导致更高的代码覆盖率？

我们将测试集与随机选择进行比较，因为这是在软件开发的早期阶段就可以使用的基线技术。更复杂的测试技术将需要被测试软件的可执行版本，因此不可比。为了提供合理预期的覆盖范围上限，我们将结果与事后贪婪算法（在下面的IV-C节中进行了描述）进行比较，并根据其结果归一化所达到的覆盖范围。这样，我们可以比较不同测试软件之间的结果。对于这三种方法，我们研究了覆盖范围随测试集大小增加而增长的速度。

在初步实验期间，很明显，每个测试输入的大小是确定多样性并因此利用I-TSDm的关键特征：基于TSDm1的选择将首先在测试集中包括任何长测试输入，然后逐渐包括较短的测试输入。回想起来，这是有道理的，因为平均而言，测试输入越长，与其他输入不同的空间就越大。但是，这意味着存在以下风险：调查RQ2时看到的任何影响仅是由于输入大小而不是给定大小的输入之间的差异所致。

#### RQ3-结构覆盖能力W.大小限制
当我们控制测试输入的大小时，基于I-TSDm选择的测试集是否比随机选择的测试集导致更高的代码覆盖率？

即使我们使用[18]的测试数据生成技术可以生成具有特定大小的数据，我们还是在这里使用一种更简单的方法，以避免在生成的输入中引入不必要的偏差：生成大量输入，并且仅选择接近目标尺寸的那些。我们改变目标的大小，并在初始的测试用例池中包括在目标的10％以内的生成的输入。

仅覆盖程序的较大部分是不够的。我们最终想要的是找到故障，以便我们消除故障。通过研究存在种子故障的SUT，我们可以研究故障发现能力的任何好处。

#### RQ4-故障查找能力
与基于随机选择的测试集相比，基于I-TSDm选择的测试集是否会导致更高的故障覆盖率？

基于II-B节所述的Cohen和Vitnyis算法的I-TSDMm度量在理论上将缩放为（N2）（请参阅II-B节），其中N是从中选择的初始测试池的大小。我们在实践中研究了选择过程的实现的可伸缩性，并给出了对于实际大小的测试集可能期望的实际时间的指示。

RQ5：选择时间
随着初始池的大小增加，执行选择方法的时间如何缩放？

### B.软件主题

JEuclid 3.1.9是一个Java库，可从MathML渲染图像，MathML是一种用于描述数学方程式表示形式的XML格式[19]。该库由将MathML作为输入并以SVG格式呈现的方程式作为输出的应用程序执行。该主题的输入是根据MathML 2.0的XML Schema规范生成的。有关详细信息，请参阅[20]。由于SVG渲染只是JEuclid的众多功能之一，因此我们将覆盖范围的测量限制在JEuclid核心渲染和文档处理模块上，而不是整个库中。核心模块具有11,556条非注释，非空白的代码行（SLOC）。

**ROME** 1.0是一个Java库，用于解析和转换RSS和Atom XML格式以供联合供稿[21]。该库由一个应用程序执行，该应用程序将Atom提要作为输入，解析提要，然后将内容和结构输出为文本。输入是基于Atom 1.0的XML Schema规范生成的。我们测量整个ROME库的覆盖范围，该库具有11,704个SLOC。

**NanoXML**是用于解析XML的小型Java库。我们使用内布拉斯加州林肯大学维护的软件工件基础结构存储库（SIR）中的NanoXML版本[22]。该库由一个应用程序执行，该应用程序是SIR为此提供的软件的变体。该应用程序将XML作为输入，对其进行解析，然后将内容和结构作为文本输出。使用MathML生成器生成这些输入，该生成器也用于JEuclid。我们测量了整个NanoXML库的覆盖范围，该库具有1,630个SLOC。

**Replace**是来自软件工件基础结构存储库的C应用程序，它执行模式匹配和替换。它需要三个输入：一个要修改的字符串，一个定义匹配文本的正则表达式以及一个替换匹配文本的字符串。正则表达式是使用自定义生成器根据Replace的规范生成的；待修改的字符串和替换字符串将作为大小在0到32个字符之间的字符的随机序列生成。该应用程序有538 SLOC。

### C.措施
所有实验均在配备2.7Ghz Intel Core i7 CPU和16GB DDR3内存的MacBook Pro（2012年中，视网膜）上运行。实验框架以及与TSDm和NCD相关的代码均以Julia编程语言实现[23]。对于所有实验，我们使用了Julia版本0.3.8（2015-04-30）。除非另有说明，否则所有实验均使用10次独立重复。

#### 1）覆盖范围
JaCoCo 0.7.4 [24]用于衡量Java主题：Jeuclid，ROME和NanoXML的结构覆盖率。 JaCoCo在Java虚拟机运行时以字节码级别收集覆盖率信息，因此不需要检测代码。 JaCoCo评估了许多结构覆盖率指标：在这项工作中，使用的指标是指令覆盖率。

对于替换主题，根据检测应用程序中的种子错误评估覆盖率。该评估使用了软件工件基础结构存储库提供的32个应用程序变体：每个变体包含一个已手动植入的故障（由于与用于执行实验的框架相关的原因，因此排除了32个变体中的1个，因此认为未检测到）通过任何测试用例）。如果该变体的输出和/或返回状态与未修改的应用程序的输出和/或返回状态不同，则认为已通过测试用例检测到故障。

#### 2）贪婪覆盖算法
贪婪算法以空测试集开始。在每次迭代时，它都会考虑池中剩余的所有测试用例，并从这些测试用例中选择一个测试用例，如果将其添加到集合中，则可以最大程度地提高集合所达到的覆盖率。然后将该测试用例从池中删除，并添加到测试集中。在回归测试中，这种贪婪算法被称为“其他”方法[25]。 I-TSDm仅使用测试输入本身来选择测试用例，而贪婪算法使用通过使用测试输入动态执行被测软件而获得的信息。因此，我们认为，使用给定的测试用例池，由贪婪算法实现的覆盖范围是可以合理实现的最佳覆盖范围。

### D.实验1：与代码覆盖率的相关性

为了研究I-TSDm和代码覆盖率之间的关系，我们希望使用大量的测试集，并尽可能扩大测试集直径。然后，我们可以测量它们的代码覆盖率，并研究是否存在任何关联。如果我们要随机抽样子集，则很有可能获得的大多数测试集具有平均直径，因此将无法评估其整个值范围内的相关性。仅增加样本数量是不可行的，因为这将花费很长时间评估所有样本的代码覆盖率。

因此，我们基于对1000个随机生成的测试输入的I-TSDm初始应用，选择了测试子集的分层采样。这些测试输入按在I-TSDm选择过程中被删除的顺序考虑，并分为10个连续的层：层1包含编号为1到100的测试输入，层2包含编号为101到200的数字，依此类推。要为实验1选择测试集，我们随机选择一个层次，然后在该层次内随机抽样输入。我们对子集大小10、25和50的每个子集重复此过程100次。这种分层采样可确保更好地分散TSDm值，并允许我们研究与代码覆盖率的任何相关性。

**[表一：三种不同的sut和三种不同的测试集大小的I-TSDM与指令覆盖率之间的Spearman等级相关性值]**

在表I中，我们可以显示三个调查的SUT中的每个以及每个调查的子集大小的Spearman等级相关值。在所有情况下，我们都可以拒绝零假设，即p值小于10-4时I-TSDm与指令覆盖率之间不存在相关性，而替代性假设是相关性高于0。

相关值在0.40到0.82的范围内，其中一个异常值（NanoXML在子集大小为50）具有较低的相关值（0.26）。总的来说，I-TSDm与指令覆盖率之间的相关性可以认为是中等正相关性。在图1中，使用相同的标尺覆盖率（y轴）和I-TSDm（x轴），将每个主题的三个集合彼此相邻地绘制。可以最清楚地看到该模式，即随着I-TSDm值平均随测试集大小的增加而增加，并且覆盖率值也可以看到相同的趋势。例如，对于ROME，测试集大小10、20和50的平均覆盖率分别为0.254、0.277和0.285。还应注意，随着子集大小的增加，TSDm值的分布会缩小，并且对于较小的子集大小，通常会有更多的变化。

平均而言，具有更大输入直径（I-TSDm）的测试仪具有更高的代码覆盖率。

### E.实验2：结构覆盖率
由于实验1证明了I-TSDm与代码覆盖率之间的相关性，因此我们可以合理地期望TSDm选择过程可以用来选择高覆盖率测试集。实验2的结果证实了这种情况。

图2是使用I-TSDm选择的测试集实现的覆盖范围的典型示例。该图针对使用贪婪算法（红色），I-TSDm1过程（绿色）和随机算法（蓝色）从250个随机生成的MathML输入的初始池中选择的测试集的大小，绘制了ROME库的指令覆盖率与大小的关系。将结果平均10次，并归一化为使用贪心算法得出的测试集所达到的最大覆盖率。

表II以不同的方式解释了相同的结果，表II显示了使用I-TSDm或随机选择达到最大覆盖率的90％，95％和99％所需的测试集的平均大小。平均而言，随机选择程序需要的测试集比使用I-TSDm选择的集大2至6倍。例如，与随机选择相比，使用I-TSDm1过程选择的实现95％标准化覆盖率的测试集要小77％（ROME），80％（NanoXML）和83％（JEuclid）。

**[图。1：散点图显示了从10个不同层中随机采样的三个不同大小（分别为10个，25个和50个测试输入）的测试集的input-tsdm（x轴）与指令覆盖率（y轴）之间的相关性。 当子集最小时，通过I-tsdm选择程序选择的测试输入从层中采样颜色较深的测试集。]**

**[图2：针对使用贪婪算法（红色），I-TSDM1过程（绿色）和随机算法（蓝色）从250个随机生成的初始池中选择的测试集的大小，ROME库的指令覆盖率（标准化）与大小的关系 MathML输入。 该图显示了10次运行的平均值。]**

**[表II：使用I-TSDM1程序和随机算法从250个输入的初始池中选择测试输入时，平均测试集大小需要达到贪婪算法达到的最大指令覆盖率的90％，95％和99％]**

为最大测试输入直径选择的测试集比随机选择的测试集具有更高的代码覆盖率。

但是，如果我们看一下由I-TSDm1过程选择的测试输入的长度，我们可以看到测试用例的长度与首次包含它们的测试集的大小之间几乎完美的相关性。图3绘制了一个这样的测试集序列（对于JEuclid）的测试输入长度。在这种情况下，Spearman等级相关性为0.96，对于ROME为0.93，对于NanoXML为0.96。

在事后看来，这种影响是显而易见的：输入的时间越长，输入执行被测软件的不同部分的机会就越大。这表明，与其使用复杂的测试设计策略（例如TSDm），不如简单地选择一些大型测试输入就足以覆盖输入空间的各个方面。在接下来的实验中，我们探讨I-TSDM是否有益时，控制输入长度的影响。

### F.实验3：长度约束下的结构覆盖率
在此实验中，当测试输入的长度限制在较小范围内时，将探索I-TSDm的优势。这与实践中限制测试输入长度的要求相对应：即使测试生成过程是自动化的，oracle也可能是手动的，因此测试输入时间越长，难度就越大，成本也就越高。应用预言[26]。为了评估TSDm是否可以在这种情况下提供帮助，我们重新进行了实验2，但使用生成和过滤方法将初始池中的输入长度限制在目标长度的10％以内，即生成了随机输入，而外部输入允许的长度间隔被丢弃。

**[图。 3：对于一个测试集序列，通过I-TSDm1程序从初始池大小250中选择的测试输入（对于JEuclid）的长度与最初包含它们的测试集的大小作图。灰色水平线表示平均值351.4。]**

**[图。 4：针对使用贪婪算法（红色），I-TSDm1过程（绿色）和随机算法（蓝色）从250个随机生成的mathml输入的初始池中选择的测试集的大小，ROME库的指令覆盖率（标准化）长度在90到110个字节之间。该图显示了10次的平均值。]**

**[表III：使用I-TSDM1程序和随机算法从初始池250中选择测试输入时，平均测试集大小需要达到贪婪算法达到的最大指令覆盖率的90％，95％和99％输入的长度在90到110个字节之间]**

图4显示了随着测试集的大小增加，指令覆盖率（规范化）如何增长的图表。这对应于上面的图2，但此处初始池中的输入长度已限制为90-110字节。我们可以看到，与贪婪算法相比，使用I-TSDm选择的测试集的覆盖范围现在比在输入长度不受限制的情况下更具竞争力。但是，与随机选择的测试集相比，它仍然保持相当大的优势。我们对几种目标长度进行了测试，所有这些长度都在+/- 10％的任意长度范围内适用于生成和过滤方法，并且模式一直持续到目标长度变大并且基于多样性进行选择的优势逐渐减弱。看起来，当每个输入的时间足以执行大部分预期的行为时，我们可以选择任意一个，即随机选择“赶上来”。因此，基于多样性的选择似乎可以用于自动测试生成的应用程序中，因为人们通常会选择较短的时间而不是较长的测试输入和测试用例，因此人们将着眼于生成的测试。

表III显示了达到这些测试集中任何一个的最大指令覆盖率的不同级别的平均测试集大小。我们注意到，对于给定的覆盖水平，使用I-TSDm1程序选择的测试集比随机选择的集小2至9倍。例如，使用I-TSDm1程序选择的测试集与使用随机选择的方法相比，缩小了49％（NanoXML），57％（ROME）和70％（JEuclid）的测试集。

将这些结果与表II进行比较，很明显，与输入长度不受限制时相比，需要更大的测试集，并且这对于I-TSDm和随机算法均会发生。对于ROME，使用I-TSDm大约需要22个输入的测试集才能达到95％的覆盖率，而在长度受到限制时，仅需要3个输入。但是，我们在比较这些表时要格外小心，因为某些SUT达到的非标准化覆盖率值有所不同。对于NanoXML和ROME，在有和没有长度限制的情况下，获得了相似的覆盖级别，分别为36.1％和32.8％；但是对于JEuclid，当输入长度受限制时，覆盖率达到46.8％，而不受限制时达到59.8％。

即使我们控制测试输入的大小，测试集直径也会导致更高的代码覆盖率；测试多样性不仅仅是输入长度。

我们注意到，在以后的工作中，应该比较和搜索测试集时调查测试集每位（或字节）的覆盖能力是否是有用的指标。我们关于测试用例长度的重要性的结果表明，考虑测试集的总长度非常重要。

**[图5：针对使用贪婪算法（红色），I-TSDm1过程（绿色）和随机算法（蓝色）从250个随机生成的初始输入池中选择的测试集的大小对替换SUT的故障覆盖率（标准化） 9到11个字节之间的正则表达式。这些图是10次重复运行的平均值。]**

### G.实验4：故障发现能力
对于有效的测试，结构覆盖范围还不够。最终目的是发现故障。在本实验中，我们使用带有种子故障的Replace SUT的变体来比较选择测试输入的不同过程的故障发现能力。如第IV-B节所述，此SUT接受三个输入，但是在确定执行路径时，正则表达式输入到目前为止是最重要的。因此，我们仅考虑并控制此输入的长度。

图5显示，平均而言，I-TSDm选择的故障覆盖率要比随机选择的测试覆盖率高，而贪婪算法的故障发现能力则明显优于两者。使用I-TSDm1程序选择的测试集达到95％的标准化故障覆盖率比随机选择的测试集小45％。

具有更大测试集直径（I-TSDm）的测试集可能具有更好的故障查找能力。

当然，有必要将I-TSDm应用于更广泛的SUT的测试集选择中的其他实验，才能确信此结果的普遍性。

### H.实验5：测试集选择时间
通过收集上述实验中I-TSDm测试选择程序的运行时间，我们可以对其性能进行建模。由于我们期望整体的缩放比例为（N2）（请参阅第二部分），因此我们研究了包含该术语的几种不同模型。我们发现，形式为Savg×N2的模型，其中Savg是所选字符串的平均长度，N是初始池中元素的数量，很好地解释了观察到的时间。这是自然的；我们期望压缩的元素的平均长度具有线性缩放比例，以及NCD1缩减程序的（N2）缩放比例。当我们使用普通最小二乘回归拟合该模型时，R2拟合优度的值超过0.99。

TSDm测试选择程序在要选择的初始测试库大小中按平方缩放，并且与平均测试长度成线性关系。

在实践中，这意味着我们试验的机器上需要40–60分钟的计算时间，以初始存储1000个测试输入，平均大小为数百个字节。未来的工作应研究加快流程的方法；可能可以使用成对NCD计算基于初始滤波并行化计算和/或利用近似值。

## 第五节 讨论
我们已经提出了测试集直径（TSDm）作为多样性度量标准的一个系列，这些通用性适用于软件测试的生成和分析。我们的实证研究将TSDm应用于从随机生成的测试输入库中选择测试集，并确认它与结构代码覆盖率具有中等到高度的相关性。这一点很重要，因为它可以在开发过程的早期使用，并且使用的度量标准既不是数据类型也不是域特定的，因此可以在没有进一步专门化的情况下被普遍使用。该研究的重要结果是与随机选择测试集相比，TSDm选择程序的优越性。对于三个采用基于XML的输入的Java软件系统，TSDm选择的测试集比达到相同，高覆盖率水平的随机选择的集小2至9倍。并且，在使用由天真的实现的生成器生成的输入池以C语言实现的软件功能上，与随机选择相比，TSDm展示了更高的故障覆盖率。但是，计算TSDm并不便宜。甚至其近似值也与从中选择测试用例的池的大小成四倍地缩放。

我们的结果对理论和实践都有影响。在软件工程中普遍缺乏理论[27]，但是正如Chen等人[27]在讨论自适应随机测试的优点时已经指出的那样，多样性是软件测试中大量结果的共同线索。通过基于信息论[9] [10]从理论上有充分依据的多样性观点，我们可以形式化多样性在软件测试中的含义，并探讨是否存在限制律。正如我们在其他地方所论证的[28]，从信息论到软件测试有许多联系，但是多样性量化是一个重要的联系，应进一步探索。我们在考虑产生的测试输入的长度的重要性方面的结果也应该提醒自动化软件测试中的其他研究人员。他们的结果对生成的测试用例的不同大小有效吗？

对于实践，我们的结果有很多含义。显然，TSDm可用于选择比随机选择的测试集更有效的测试集。即使并非总是如此，应用I-TSDm似乎没有什么风险，因为在早期的软件开发阶段几乎没有其他替代技术可以应用。即使测试人员将继续手动选择测试用例，他们也可以使用TSDm搜索其他测试用例，这些用例最大程度地增加了整个测试集的直径[18]，[29]。这个过程甚至可以是交互式的：向测试人员迭代地展示高度多样化的测试用例，供您从[30]，[31]中进行选择。

我们的结果的一个有趣的实际含义是，我们可以使用TSDm分析现有的测试套件。例如，在TSDm的测试集中订购手动创建的测试用例，将结果可视化并与测试人员讨论，可能会导致对测试用例相对重要性的见解，其方式类似于历史测试结果[32] ]。这也可以帮助指导减少测试集，以及评估新提议的测试用例，这将最大程度地增加测试集的多样性。

除了测试选择过程时间的二次标度外，我们的方法还有很多其他限制。使用NCD的一个缺点是，不清楚两个测试用例之间差异的基础是什么。测试集不仅用于发现故障或确保覆盖范围，而且还是软件系统质量，可靠性和安全性争论中的重要元素。对于这种用例，不仅可以选择测试用例，而且可以解释为什么要进行选择的方法将带来好处。创建基于NCD的系统似乎比基于特定于数据类型的指标创建系统更困难。

另一个限制是我们还不了解压缩算法的选择对NCD指标的影响。在非正式调查中，我们发现TSDm结果对于所用压缩算法的变化具有鲁棒性。但是，许多压缩算法具有一些特殊的设计或实现选择，这可能使它们或多或少地适合于NCD计算。例如，我们尝试将默认的Zlib压缩器切换为Blosc库中某些更快的压缩器[33]。但是，如果输入字符串小于128字节，则它们根本不会压缩。这种不连续性可能会对应用基于NCD的指标带来的价值产生负面影响。初步研究表明，对于多集合的NCD而言，这对成对NCD计算而言，问题不大，因为前者连接多个字符串，因此通常会导致更长的字符串。

NCD在多集合上的通用性可能会使其在测试中分析和利用与测试无关的软件信息也很有吸引力。例如，可以在软件工件中找到的文本（例如需求，规范，设计文档和源代码）可以用于查找与此类信息接近或不同的两个测试用例。但是，我们注意到基本的NCD度量可能不适用于已命名的事物，而不是自我描述的事物。 Cilibrasi和Vitányi已提议对此类信息使用归一化Web距离[34]。出于软件测试目的探索此指标仍然是未来工作的重要领域。

与I-TSDm测试集选择进行比较的另一种方法是手动选择，即由人类创建的测试集。对于两个SUT，我们已经研究了软件工件基础结构存储库（SIR）提供的测试集，但是用于创建测试用例的测试策略并不总是很明确，因此我们无法可靠地将它们用于此目的。因此，对于本研究，我们将贪婪选择算法获得的最大覆盖范围视为人类测试人员可以达到的最佳近似值。尽管如此，未来的研究应该更详细地研究与手动选择的比较。

## 第六节 相关工作
关于更多样化的测试集对软件测试有利的观念已经存在了一段时间。文献中变化的是定义多样性的距离的定义。在非常有限的意义上，多样性可以解释为试图不重复使用相同的测试用例子集。 Kim和Porter将此想法作为基于历史记录的测试优先级来实现，其中选择测试用例的机会与自上次执行以来所经过的时间成比例[35]。 Yoo等。认为重复使用同一子集会“磨损”所选的测试用例，并建议在每次测试迭代中使用不同的子集[36]。尽管可以认为这些工作涉及测试多样性，但它们仅限于充分利用给定的一组测试，并且无法帮助测试工程师比较两组测试。

测试执行跟踪已用作更丰富的多样性度量的基础。 Leon和Podgurski [37]使用比例二进制距离（二进制字符串的欧几里得距离的变化）来聚类测试覆盖向量，并得出结论，选择的测试子集越多样化，故障检测能力就越高。 Nikolik将控制和数据流信息都纳入了测试多样性的定义中[38]。 Ciupa等。通过将两个对象实例之间的距离定义为基本成员之间距离的加权总和，介绍了面向对象编程语言的对象距离[39]。 Bueno等人[5]介绍了一种基于欧几里得距离的成对测试集多样性测度，并在自适应随机测试的背景下应用了元启发式搜索。在后来的研究中，作者提到可以使用其他距离度量，但经验工作仅研究数值矢量[40]。现有工作中的共同点是欧几里得距离，汉明距离或Levenshtein距离的基本用法，这要么限制了该技术对数值数据的适用性，要么失去了高级语义。相反，我们使用了通用距离度量NCD，它没有依赖于数值矢量，并且已被证明可以处理数据中的高级语义。费尔德等。 [8]将NCD应用到测试执行跟踪中，但是以成对方式进行，因此无法像我们在这里那样帮助测试工程师比较测试用例集。与此相关的是Hemmati等[41]的工作，该工作研究了成对应用于基于模型的测试中的抽象测试用例的大量不同相似性函数。他们的论文可以广泛地描述现有的成对距离函数。

获得测试执行轨迹需要对SUT进行检测。相反，Alsahwan和Harman仅专注于SUT的输出[6]，[7]，并表明具有更多输出的测试集可以产生相应更高的故障检测能力和结构覆盖率。尽管Alsahwan和Harman的工作着眼于观察到的输出的多样性，但当前的论文着眼于测试输入的多样性，从而允许甚至在测试执行或系统实施之前就进行分析。由于多集NCD也可以应用于输出，所以一个更根本的区别是Alshawan和Harman的输出唯一性度量本质上是二进制的，因为它们仅判断两个输出是否不同。相反，这里使用的NCD度量也可以量化输出之间的差异。这对于具有较大输出空间的软件系统非常重要，在该软件系统中，大多数输入可能返回唯一的输出，或者通常，因为与二进制相比，它给出的分级响应更大。相反，Alshawan和Harman的方法在判断唯一性之前会过滤输出，因此可以考虑不同方面的唯一性。但是，如[8]所述，也可以在应用NCD之前使用过滤器。未来的工作应该调查过滤器和/或二进制唯一性相对于输入和输出的连续测量（例如NCD）的相对优势。

## 第七节 结论

尽管人们一直争论带有更多不同测试用例的测试集会更好，但这一概念仍然模糊不清，难以在实践中应用。先前的研究要么只专注于测试对之间的距离测量，要么仅限于特定的数据类型。在本文中，我们提出了一种称为测试集直径（TSDm）的度量，该度量可衡量整个测试集的多样性。它具有Kolmogorov复杂性的正式基础，适用于任何数据类型和与测试相关的信息源。通过使用现代压缩算法对其进行近似计算，可以将其实际用于测试选择和分析。

我们的经验工作评估了应用于测试输入的TSDm。这是自动化测试中比较艰巨的任务之一；我们甚至不需要开始实施我们要测试的软件的程序。我们的结果表明，输入的TSDm量度与三个开源Java系统的指令覆盖率显示出中等到高度的正相关。基于TSDm的测试选择过程可以采用事后贪婪测试选择过程，该过程需要初始池中所有测试输入的实际覆盖率信息。但是，TSDm的成功似乎部分是通过尽早选择大型测试输入来实现的。通过控制输入大小，我们表明，与随机选择相比，TSDm仍然具有相当大的优势。最后，我们将输入的TSDm选择程序应用于以C编写的植入了故障的软件。对故障覆盖率有积极影响：达到相同故障覆盖率水平的测试集要比随机选择的测试集小27至45％。

我们认为，能够基于测试集的多样性对测试集进行排名对于总体而言对软件质量至关重要。但是，多样性量化还不够。根据我们的经验研究，我们推测很多因素共同决定了测试集的有效性，包括测试数据生成器的多样性以及从中选择的初始库的大小和多样性。未来的工作应详细评估它们并量化其效果。我们建议，这可以导致对测试质量以及改进它的实用技术有更基本的了解。





## 致谢

这项工作部分由知识基金会（KKS）通过项目20130085关键系统特性测试（TOCSYC）资助。aa